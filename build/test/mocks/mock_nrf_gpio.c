/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "cmsis_iccarm.h"
#include "mock_nrf_gpio.h"

static const char* CMockString_clr_mask = "clr_mask";
static const char* CMockString_dir = "dir";
static const char* CMockString_dir_mask = "dir_mask";
static const char* CMockString_direction = "direction";
static const char* CMockString_drive = "drive";
static const char* CMockString_in_mask = "in_mask";
static const char* CMockString_input = "input";
static const char* CMockString_length = "length";
static const char* CMockString_nrf_gpio_cfg = "nrf_gpio_cfg";
static const char* CMockString_nrf_gpio_cfg_default = "nrf_gpio_cfg_default";
static const char* CMockString_nrf_gpio_cfg_input = "nrf_gpio_cfg_input";
static const char* CMockString_nrf_gpio_cfg_output = "nrf_gpio_cfg_output";
static const char* CMockString_nrf_gpio_cfg_sense_input = "nrf_gpio_cfg_sense_input";
static const char* CMockString_nrf_gpio_cfg_sense_set = "nrf_gpio_cfg_sense_set";
static const char* CMockString_nrf_gpio_cfg_watcher = "nrf_gpio_cfg_watcher";
static const char* CMockString_nrf_gpio_input_disconnect = "nrf_gpio_input_disconnect";
static const char* CMockString_nrf_gpio_latches_read = "nrf_gpio_latches_read";
static const char* CMockString_nrf_gpio_latches_read_and_clear = "nrf_gpio_latches_read_and_clear";
static const char* CMockString_nrf_gpio_pin_clear = "nrf_gpio_pin_clear";
static const char* CMockString_nrf_gpio_pin_dir_get = "nrf_gpio_pin_dir_get";
static const char* CMockString_nrf_gpio_pin_dir_set = "nrf_gpio_pin_dir_set";
static const char* CMockString_nrf_gpio_pin_input_get = "nrf_gpio_pin_input_get";
static const char* CMockString_nrf_gpio_pin_latch_clear = "nrf_gpio_pin_latch_clear";
static const char* CMockString_nrf_gpio_pin_latch_get = "nrf_gpio_pin_latch_get";
static const char* CMockString_nrf_gpio_pin_out_read = "nrf_gpio_pin_out_read";
static const char* CMockString_nrf_gpio_pin_present_check = "nrf_gpio_pin_present_check";
static const char* CMockString_nrf_gpio_pin_pull_get = "nrf_gpio_pin_pull_get";
static const char* CMockString_nrf_gpio_pin_read = "nrf_gpio_pin_read";
static const char* CMockString_nrf_gpio_pin_sense_get = "nrf_gpio_pin_sense_get";
static const char* CMockString_nrf_gpio_pin_set = "nrf_gpio_pin_set";
static const char* CMockString_nrf_gpio_pin_toggle = "nrf_gpio_pin_toggle";
static const char* CMockString_nrf_gpio_pin_write = "nrf_gpio_pin_write";
static const char* CMockString_nrf_gpio_port_dir_input_set = "nrf_gpio_port_dir_input_set";
static const char* CMockString_nrf_gpio_port_dir_output_set = "nrf_gpio_port_dir_output_set";
static const char* CMockString_nrf_gpio_port_dir_read = "nrf_gpio_port_dir_read";
static const char* CMockString_nrf_gpio_port_dir_write = "nrf_gpio_port_dir_write";
static const char* CMockString_nrf_gpio_port_in_read = "nrf_gpio_port_in_read";
static const char* CMockString_nrf_gpio_port_out_clear = "nrf_gpio_port_out_clear";
static const char* CMockString_nrf_gpio_port_out_read = "nrf_gpio_port_out_read";
static const char* CMockString_nrf_gpio_port_out_set = "nrf_gpio_port_out_set";
static const char* CMockString_nrf_gpio_port_out_write = "nrf_gpio_port_out_write";
static const char* CMockString_nrf_gpio_ports_read = "nrf_gpio_ports_read";
static const char* CMockString_nrf_gpio_range_cfg_input = "nrf_gpio_range_cfg_input";
static const char* CMockString_nrf_gpio_range_cfg_output = "nrf_gpio_range_cfg_output";
static const char* CMockString_out_mask = "out_mask";
static const char* CMockString_p_masks = "p_masks";
static const char* CMockString_p_reg = "p_reg";
static const char* CMockString_pin_number = "pin_number";
static const char* CMockString_pin_range_end = "pin_range_end";
static const char* CMockString_pin_range_start = "pin_range_start";
static const char* CMockString_pull = "pull";
static const char* CMockString_pull_config = "pull_config";
static const char* CMockString_sense = "sense";
static const char* CMockString_sense_config = "sense_config";
static const char* CMockString_set_mask = "set_mask";
static const char* CMockString_start_port = "start_port";
static const char* CMockString_value = "value";

typedef struct _CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_range_start;
  uint32_t Expected_pin_range_end;

} CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_range_start;
  uint32_t Expected_pin_range_end;
  nrf_gpio_pin_pull_t Expected_pull_config;

} CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_cfg_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;
  nrf_gpio_pin_dir_t Expected_dir;
  nrf_gpio_pin_input_t Expected_input;
  nrf_gpio_pin_pull_t Expected_pull;
  nrf_gpio_pin_drive_t Expected_drive;
  nrf_gpio_pin_sense_t Expected_sense;

} CMOCK_nrf_gpio_cfg_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;
  nrf_gpio_pin_pull_t Expected_pull_config;

} CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;
  nrf_gpio_pin_pull_t Expected_pull_config;
  nrf_gpio_pin_sense_t Expected_sense_config;

} CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;
  nrf_gpio_pin_sense_t Expected_sense_config;

} CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;
  nrf_gpio_pin_dir_t Expected_direction;

} CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_set_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_set_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_write_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;
  uint32_t Expected_value;

} CMOCK_nrf_gpio_pin_write_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_read_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce uint32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_read_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce uint32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce nrf_gpio_pin_sense_t ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce nrf_gpio_pin_dir_t ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce nrf_gpio_pin_input_t ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce nrf_gpio_pin_pull_t ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  NRF_GPIO_Type* Expected_p_reg;
  uint32_t Expected_out_mask;

} CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  NRF_GPIO_Type* Expected_p_reg;
  uint32_t Expected_in_mask;

} CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  NRF_GPIO_Type* Expected_p_reg;
  uint32_t Expected_dir_mask;

} CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce uint32_t ReturnVal;
  int CallOrder;
  NRF_GPIO_Type const* Expected_p_reg;

} CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce uint32_t ReturnVal;
  int CallOrder;
  NRF_GPIO_Type const* Expected_p_reg;

} CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce uint32_t ReturnVal;
  int CallOrder;
  NRF_GPIO_Type const* Expected_p_reg;

} CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  NRF_GPIO_Type* Expected_p_reg;
  uint32_t Expected_value;

} CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  NRF_GPIO_Type* Expected_p_reg;
  uint32_t Expected_set_mask;

} CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  NRF_GPIO_Type* Expected_p_reg;
  uint32_t Expected_clr_mask;

} CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_ports_read_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_start_port;
  uint32_t Expected_length;
  uint32_t* Expected_p_masks;

} CMOCK_nrf_gpio_ports_read_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_latches_read_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_start_port;
  uint32_t Expected_length;
  uint32_t* Expected_p_masks;

} CMOCK_nrf_gpio_latches_read_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_start_port;
  uint32_t Expected_length;
  uint32_t* Expected_p_masks;

} CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce uint32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce void ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE;

typedef struct _CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  inluce bool ReturnVal;
  int CallOrder;
  uint32_t Expected_pin_number;

} CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE;

static struct mock_nrf_gpioInstance
{
  char nrf_gpio_range_cfg_output_IgnoreBool;
  inluce void nrf_gpio_range_cfg_output_FinalReturn;
  char nrf_gpio_range_cfg_output_CallbackBool;
  CMOCK_nrf_gpio_range_cfg_output_CALLBACK nrf_gpio_range_cfg_output_CallbackFunctionPointer;
  int nrf_gpio_range_cfg_output_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_range_cfg_output_CallInstance;
  char nrf_gpio_range_cfg_input_IgnoreBool;
  inluce void nrf_gpio_range_cfg_input_FinalReturn;
  char nrf_gpio_range_cfg_input_CallbackBool;
  CMOCK_nrf_gpio_range_cfg_input_CALLBACK nrf_gpio_range_cfg_input_CallbackFunctionPointer;
  int nrf_gpio_range_cfg_input_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_range_cfg_input_CallInstance;
  char nrf_gpio_cfg_IgnoreBool;
  inluce void nrf_gpio_cfg_FinalReturn;
  char nrf_gpio_cfg_CallbackBool;
  CMOCK_nrf_gpio_cfg_CALLBACK nrf_gpio_cfg_CallbackFunctionPointer;
  int nrf_gpio_cfg_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_cfg_CallInstance;
  char nrf_gpio_cfg_output_IgnoreBool;
  inluce void nrf_gpio_cfg_output_FinalReturn;
  char nrf_gpio_cfg_output_CallbackBool;
  CMOCK_nrf_gpio_cfg_output_CALLBACK nrf_gpio_cfg_output_CallbackFunctionPointer;
  int nrf_gpio_cfg_output_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_cfg_output_CallInstance;
  char nrf_gpio_cfg_input_IgnoreBool;
  inluce void nrf_gpio_cfg_input_FinalReturn;
  char nrf_gpio_cfg_input_CallbackBool;
  CMOCK_nrf_gpio_cfg_input_CALLBACK nrf_gpio_cfg_input_CallbackFunctionPointer;
  int nrf_gpio_cfg_input_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_cfg_input_CallInstance;
  char nrf_gpio_cfg_default_IgnoreBool;
  inluce void nrf_gpio_cfg_default_FinalReturn;
  char nrf_gpio_cfg_default_CallbackBool;
  CMOCK_nrf_gpio_cfg_default_CALLBACK nrf_gpio_cfg_default_CallbackFunctionPointer;
  int nrf_gpio_cfg_default_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_cfg_default_CallInstance;
  char nrf_gpio_cfg_watcher_IgnoreBool;
  inluce void nrf_gpio_cfg_watcher_FinalReturn;
  char nrf_gpio_cfg_watcher_CallbackBool;
  CMOCK_nrf_gpio_cfg_watcher_CALLBACK nrf_gpio_cfg_watcher_CallbackFunctionPointer;
  int nrf_gpio_cfg_watcher_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_cfg_watcher_CallInstance;
  char nrf_gpio_input_disconnect_IgnoreBool;
  inluce void nrf_gpio_input_disconnect_FinalReturn;
  char nrf_gpio_input_disconnect_CallbackBool;
  CMOCK_nrf_gpio_input_disconnect_CALLBACK nrf_gpio_input_disconnect_CallbackFunctionPointer;
  int nrf_gpio_input_disconnect_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_input_disconnect_CallInstance;
  char nrf_gpio_cfg_sense_input_IgnoreBool;
  inluce void nrf_gpio_cfg_sense_input_FinalReturn;
  char nrf_gpio_cfg_sense_input_CallbackBool;
  CMOCK_nrf_gpio_cfg_sense_input_CALLBACK nrf_gpio_cfg_sense_input_CallbackFunctionPointer;
  int nrf_gpio_cfg_sense_input_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_cfg_sense_input_CallInstance;
  char nrf_gpio_cfg_sense_set_IgnoreBool;
  inluce void nrf_gpio_cfg_sense_set_FinalReturn;
  char nrf_gpio_cfg_sense_set_CallbackBool;
  CMOCK_nrf_gpio_cfg_sense_set_CALLBACK nrf_gpio_cfg_sense_set_CallbackFunctionPointer;
  int nrf_gpio_cfg_sense_set_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_cfg_sense_set_CallInstance;
  char nrf_gpio_pin_dir_set_IgnoreBool;
  inluce void nrf_gpio_pin_dir_set_FinalReturn;
  char nrf_gpio_pin_dir_set_CallbackBool;
  CMOCK_nrf_gpio_pin_dir_set_CALLBACK nrf_gpio_pin_dir_set_CallbackFunctionPointer;
  int nrf_gpio_pin_dir_set_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_dir_set_CallInstance;
  char nrf_gpio_pin_set_IgnoreBool;
  inluce void nrf_gpio_pin_set_FinalReturn;
  char nrf_gpio_pin_set_CallbackBool;
  CMOCK_nrf_gpio_pin_set_CALLBACK nrf_gpio_pin_set_CallbackFunctionPointer;
  int nrf_gpio_pin_set_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_set_CallInstance;
  char nrf_gpio_pin_clear_IgnoreBool;
  inluce void nrf_gpio_pin_clear_FinalReturn;
  char nrf_gpio_pin_clear_CallbackBool;
  CMOCK_nrf_gpio_pin_clear_CALLBACK nrf_gpio_pin_clear_CallbackFunctionPointer;
  int nrf_gpio_pin_clear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_clear_CallInstance;
  char nrf_gpio_pin_toggle_IgnoreBool;
  inluce void nrf_gpio_pin_toggle_FinalReturn;
  char nrf_gpio_pin_toggle_CallbackBool;
  CMOCK_nrf_gpio_pin_toggle_CALLBACK nrf_gpio_pin_toggle_CallbackFunctionPointer;
  int nrf_gpio_pin_toggle_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_toggle_CallInstance;
  char nrf_gpio_pin_write_IgnoreBool;
  inluce void nrf_gpio_pin_write_FinalReturn;
  char nrf_gpio_pin_write_CallbackBool;
  CMOCK_nrf_gpio_pin_write_CALLBACK nrf_gpio_pin_write_CallbackFunctionPointer;
  int nrf_gpio_pin_write_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_write_CallInstance;
  char nrf_gpio_pin_read_IgnoreBool;
  inluce uint32_t nrf_gpio_pin_read_FinalReturn;
  char nrf_gpio_pin_read_CallbackBool;
  CMOCK_nrf_gpio_pin_read_CALLBACK nrf_gpio_pin_read_CallbackFunctionPointer;
  int nrf_gpio_pin_read_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_read_CallInstance;
  char nrf_gpio_pin_out_read_IgnoreBool;
  inluce uint32_t nrf_gpio_pin_out_read_FinalReturn;
  char nrf_gpio_pin_out_read_CallbackBool;
  CMOCK_nrf_gpio_pin_out_read_CALLBACK nrf_gpio_pin_out_read_CallbackFunctionPointer;
  int nrf_gpio_pin_out_read_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_out_read_CallInstance;
  char nrf_gpio_pin_sense_get_IgnoreBool;
  inluce nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get_FinalReturn;
  char nrf_gpio_pin_sense_get_CallbackBool;
  CMOCK_nrf_gpio_pin_sense_get_CALLBACK nrf_gpio_pin_sense_get_CallbackFunctionPointer;
  int nrf_gpio_pin_sense_get_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_sense_get_CallInstance;
  char nrf_gpio_pin_dir_get_IgnoreBool;
  inluce nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get_FinalReturn;
  char nrf_gpio_pin_dir_get_CallbackBool;
  CMOCK_nrf_gpio_pin_dir_get_CALLBACK nrf_gpio_pin_dir_get_CallbackFunctionPointer;
  int nrf_gpio_pin_dir_get_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_dir_get_CallInstance;
  char nrf_gpio_pin_input_get_IgnoreBool;
  inluce nrf_gpio_pin_input_t nrf_gpio_pin_input_get_FinalReturn;
  char nrf_gpio_pin_input_get_CallbackBool;
  CMOCK_nrf_gpio_pin_input_get_CALLBACK nrf_gpio_pin_input_get_CallbackFunctionPointer;
  int nrf_gpio_pin_input_get_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_input_get_CallInstance;
  char nrf_gpio_pin_pull_get_IgnoreBool;
  inluce nrf_gpio_pin_pull_t nrf_gpio_pin_pull_get_FinalReturn;
  char nrf_gpio_pin_pull_get_CallbackBool;
  CMOCK_nrf_gpio_pin_pull_get_CALLBACK nrf_gpio_pin_pull_get_CallbackFunctionPointer;
  int nrf_gpio_pin_pull_get_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_pull_get_CallInstance;
  char nrf_gpio_port_dir_output_set_IgnoreBool;
  inluce void nrf_gpio_port_dir_output_set_FinalReturn;
  char nrf_gpio_port_dir_output_set_CallbackBool;
  CMOCK_nrf_gpio_port_dir_output_set_CALLBACK nrf_gpio_port_dir_output_set_CallbackFunctionPointer;
  int nrf_gpio_port_dir_output_set_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_dir_output_set_CallInstance;
  char nrf_gpio_port_dir_input_set_IgnoreBool;
  inluce void nrf_gpio_port_dir_input_set_FinalReturn;
  char nrf_gpio_port_dir_input_set_CallbackBool;
  CMOCK_nrf_gpio_port_dir_input_set_CALLBACK nrf_gpio_port_dir_input_set_CallbackFunctionPointer;
  int nrf_gpio_port_dir_input_set_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_dir_input_set_CallInstance;
  char nrf_gpio_port_dir_write_IgnoreBool;
  inluce void nrf_gpio_port_dir_write_FinalReturn;
  char nrf_gpio_port_dir_write_CallbackBool;
  CMOCK_nrf_gpio_port_dir_write_CALLBACK nrf_gpio_port_dir_write_CallbackFunctionPointer;
  int nrf_gpio_port_dir_write_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_dir_write_CallInstance;
  char nrf_gpio_port_dir_read_IgnoreBool;
  inluce uint32_t nrf_gpio_port_dir_read_FinalReturn;
  char nrf_gpio_port_dir_read_CallbackBool;
  CMOCK_nrf_gpio_port_dir_read_CALLBACK nrf_gpio_port_dir_read_CallbackFunctionPointer;
  int nrf_gpio_port_dir_read_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_dir_read_CallInstance;
  char nrf_gpio_port_in_read_IgnoreBool;
  inluce uint32_t nrf_gpio_port_in_read_FinalReturn;
  char nrf_gpio_port_in_read_CallbackBool;
  CMOCK_nrf_gpio_port_in_read_CALLBACK nrf_gpio_port_in_read_CallbackFunctionPointer;
  int nrf_gpio_port_in_read_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_in_read_CallInstance;
  char nrf_gpio_port_out_read_IgnoreBool;
  inluce uint32_t nrf_gpio_port_out_read_FinalReturn;
  char nrf_gpio_port_out_read_CallbackBool;
  CMOCK_nrf_gpio_port_out_read_CALLBACK nrf_gpio_port_out_read_CallbackFunctionPointer;
  int nrf_gpio_port_out_read_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_out_read_CallInstance;
  char nrf_gpio_port_out_write_IgnoreBool;
  inluce void nrf_gpio_port_out_write_FinalReturn;
  char nrf_gpio_port_out_write_CallbackBool;
  CMOCK_nrf_gpio_port_out_write_CALLBACK nrf_gpio_port_out_write_CallbackFunctionPointer;
  int nrf_gpio_port_out_write_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_out_write_CallInstance;
  char nrf_gpio_port_out_set_IgnoreBool;
  inluce void nrf_gpio_port_out_set_FinalReturn;
  char nrf_gpio_port_out_set_CallbackBool;
  CMOCK_nrf_gpio_port_out_set_CALLBACK nrf_gpio_port_out_set_CallbackFunctionPointer;
  int nrf_gpio_port_out_set_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_out_set_CallInstance;
  char nrf_gpio_port_out_clear_IgnoreBool;
  inluce void nrf_gpio_port_out_clear_FinalReturn;
  char nrf_gpio_port_out_clear_CallbackBool;
  CMOCK_nrf_gpio_port_out_clear_CALLBACK nrf_gpio_port_out_clear_CallbackFunctionPointer;
  int nrf_gpio_port_out_clear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_port_out_clear_CallInstance;
  char nrf_gpio_ports_read_IgnoreBool;
  inluce void nrf_gpio_ports_read_FinalReturn;
  char nrf_gpio_ports_read_CallbackBool;
  CMOCK_nrf_gpio_ports_read_CALLBACK nrf_gpio_ports_read_CallbackFunctionPointer;
  int nrf_gpio_ports_read_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_ports_read_CallInstance;
  char nrf_gpio_latches_read_IgnoreBool;
  inluce void nrf_gpio_latches_read_FinalReturn;
  char nrf_gpio_latches_read_CallbackBool;
  CMOCK_nrf_gpio_latches_read_CALLBACK nrf_gpio_latches_read_CallbackFunctionPointer;
  int nrf_gpio_latches_read_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_latches_read_CallInstance;
  char nrf_gpio_latches_read_and_clear_IgnoreBool;
  inluce void nrf_gpio_latches_read_and_clear_FinalReturn;
  char nrf_gpio_latches_read_and_clear_CallbackBool;
  CMOCK_nrf_gpio_latches_read_and_clear_CALLBACK nrf_gpio_latches_read_and_clear_CallbackFunctionPointer;
  int nrf_gpio_latches_read_and_clear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_latches_read_and_clear_CallInstance;
  char nrf_gpio_pin_latch_get_IgnoreBool;
  inluce uint32_t nrf_gpio_pin_latch_get_FinalReturn;
  char nrf_gpio_pin_latch_get_CallbackBool;
  CMOCK_nrf_gpio_pin_latch_get_CALLBACK nrf_gpio_pin_latch_get_CallbackFunctionPointer;
  int nrf_gpio_pin_latch_get_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_latch_get_CallInstance;
  char nrf_gpio_pin_latch_clear_IgnoreBool;
  inluce void nrf_gpio_pin_latch_clear_FinalReturn;
  char nrf_gpio_pin_latch_clear_CallbackBool;
  CMOCK_nrf_gpio_pin_latch_clear_CALLBACK nrf_gpio_pin_latch_clear_CallbackFunctionPointer;
  int nrf_gpio_pin_latch_clear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_latch_clear_CallInstance;
  char nrf_gpio_pin_present_check_IgnoreBool;
  inluce bool nrf_gpio_pin_present_check_FinalReturn;
  char nrf_gpio_pin_present_check_CallbackBool;
  CMOCK_nrf_gpio_pin_present_check_CALLBACK nrf_gpio_pin_present_check_CallbackFunctionPointer;
  int nrf_gpio_pin_present_check_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE nrf_gpio_pin_present_check_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_nrf_gpio_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.nrf_gpio_range_cfg_output_CallInstance;
  if (Mock.nrf_gpio_range_cfg_output_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_range_cfg_output);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_range_cfg_output_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_range_cfg_input_CallInstance;
  if (Mock.nrf_gpio_range_cfg_input_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_range_cfg_input);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_range_cfg_input_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_cfg_CallInstance;
  if (Mock.nrf_gpio_cfg_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_cfg_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_cfg_output_CallInstance;
  if (Mock.nrf_gpio_cfg_output_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_output);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_cfg_output_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_cfg_input_CallInstance;
  if (Mock.nrf_gpio_cfg_input_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_input);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_cfg_input_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_cfg_default_CallInstance;
  if (Mock.nrf_gpio_cfg_default_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_default);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_cfg_default_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_cfg_watcher_CallInstance;
  if (Mock.nrf_gpio_cfg_watcher_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_watcher);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_cfg_watcher_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_input_disconnect_CallInstance;
  if (Mock.nrf_gpio_input_disconnect_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_input_disconnect);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_input_disconnect_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_cfg_sense_input_CallInstance;
  if (Mock.nrf_gpio_cfg_sense_input_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_sense_input);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_cfg_sense_input_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_cfg_sense_set_CallInstance;
  if (Mock.nrf_gpio_cfg_sense_set_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_sense_set);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_cfg_sense_set_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_dir_set_CallInstance;
  if (Mock.nrf_gpio_pin_dir_set_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_dir_set);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_dir_set_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_set_CallInstance;
  if (Mock.nrf_gpio_pin_set_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_set);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_set_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_clear_CallInstance;
  if (Mock.nrf_gpio_pin_clear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_clear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_clear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_toggle_CallInstance;
  if (Mock.nrf_gpio_pin_toggle_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_toggle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_toggle_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_write_CallInstance;
  if (Mock.nrf_gpio_pin_write_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_write);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_write_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_read_CallInstance;
  if (Mock.nrf_gpio_pin_read_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_read);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_read_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_out_read_CallInstance;
  if (Mock.nrf_gpio_pin_out_read_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_out_read);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_out_read_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_sense_get_CallInstance;
  if (Mock.nrf_gpio_pin_sense_get_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_sense_get);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_sense_get_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_dir_get_CallInstance;
  if (Mock.nrf_gpio_pin_dir_get_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_dir_get);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_dir_get_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_input_get_CallInstance;
  if (Mock.nrf_gpio_pin_input_get_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_input_get);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_input_get_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_pull_get_CallInstance;
  if (Mock.nrf_gpio_pin_pull_get_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_pull_get);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_pull_get_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_dir_output_set_CallInstance;
  if (Mock.nrf_gpio_port_dir_output_set_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_output_set);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_dir_output_set_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_dir_input_set_CallInstance;
  if (Mock.nrf_gpio_port_dir_input_set_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_input_set);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_dir_input_set_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_dir_write_CallInstance;
  if (Mock.nrf_gpio_port_dir_write_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_write);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_dir_write_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_dir_read_CallInstance;
  if (Mock.nrf_gpio_port_dir_read_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_read);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_dir_read_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_in_read_CallInstance;
  if (Mock.nrf_gpio_port_in_read_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_in_read);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_in_read_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_out_read_CallInstance;
  if (Mock.nrf_gpio_port_out_read_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_read);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_out_read_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_out_write_CallInstance;
  if (Mock.nrf_gpio_port_out_write_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_write);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_out_write_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_out_set_CallInstance;
  if (Mock.nrf_gpio_port_out_set_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_set);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_out_set_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_port_out_clear_CallInstance;
  if (Mock.nrf_gpio_port_out_clear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_clear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_port_out_clear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_ports_read_CallInstance;
  if (Mock.nrf_gpio_ports_read_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_ports_read);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_ports_read_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_latches_read_CallInstance;
  if (Mock.nrf_gpio_latches_read_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_latches_read);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_latches_read_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_latches_read_and_clear_CallInstance;
  if (Mock.nrf_gpio_latches_read_and_clear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_latches_read_and_clear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_latches_read_and_clear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_latch_get_CallInstance;
  if (Mock.nrf_gpio_pin_latch_get_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_latch_get);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_latch_get_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_latch_clear_CallInstance;
  if (Mock.nrf_gpio_pin_latch_clear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_latch_clear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_latch_clear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.nrf_gpio_pin_present_check_CallInstance;
  if (Mock.nrf_gpio_pin_present_check_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_present_check);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.nrf_gpio_pin_present_check_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_nrf_gpio_Init(void)
{
  mock_nrf_gpio_Destroy();
}

void mock_nrf_gpio_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

inluce void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_range_cfg_output);
  cmock_call_instance = (CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_range_cfg_output_CallInstance);
  Mock.nrf_gpio_range_cfg_output_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_range_cfg_output_CallInstance);
  if (Mock.nrf_gpio_range_cfg_output_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_range_cfg_output_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_range_cfg_output_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_range_cfg_output_CallbackBool &&
      Mock.nrf_gpio_range_cfg_output_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_range_cfg_output_CallbackFunctionPointer(pin_range_start, pin_range_end, Mock.nrf_gpio_range_cfg_output_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_range_cfg_output,CMockString_pin_range_start);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_range_start, pin_range_start, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_range_cfg_output,CMockString_pin_range_end);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_range_end, pin_range_end, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_range_cfg_output_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_range_cfg_output_CallbackFunctionPointer(pin_range_start, pin_range_end, Mock.nrf_gpio_range_cfg_output_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_range_cfg_output(CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE* cmock_call_instance, uint32_t pin_range_start, uint32_t pin_range_end);
void CMockExpectParameters_nrf_gpio_range_cfg_output(CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE* cmock_call_instance, uint32_t pin_range_start, uint32_t pin_range_end)
{
  cmock_call_instance->Expected_pin_range_start = pin_range_start;
  cmock_call_instance->Expected_pin_range_end = pin_range_end;
}

void nrf_gpio_range_cfg_output_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE));
  CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_range_cfg_output_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_range_cfg_output_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_range_cfg_output_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_range_cfg_output_IgnoreBool = (char)1;
}

void nrf_gpio_range_cfg_output_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_range_cfg_output_IgnoreBool)
    Mock.nrf_gpio_range_cfg_output_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_range_cfg_output_CallInstance);
  Mock.nrf_gpio_range_cfg_output_IgnoreBool = (char)0;
}

void nrf_gpio_range_cfg_output_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_range_start, uint32_t pin_range_end, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE));
  CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_range_cfg_output_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_range_cfg_output_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_range_cfg_output_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_range_cfg_output_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_range_cfg_output(cmock_call_instance, pin_range_start, pin_range_end);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_range_cfg_output_AddCallback(CMOCK_nrf_gpio_range_cfg_output_CALLBACK Callback)
{
  Mock.nrf_gpio_range_cfg_output_IgnoreBool = (char)0;
  Mock.nrf_gpio_range_cfg_output_CallbackBool = (char)1;
  Mock.nrf_gpio_range_cfg_output_CallbackFunctionPointer = Callback;
}

void nrf_gpio_range_cfg_output_Stub(CMOCK_nrf_gpio_range_cfg_output_CALLBACK Callback)
{
  Mock.nrf_gpio_range_cfg_output_IgnoreBool = (char)0;
  Mock.nrf_gpio_range_cfg_output_CallbackBool = (char)0;
  Mock.nrf_gpio_range_cfg_output_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_range_cfg_input(uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_range_cfg_input);
  cmock_call_instance = (CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_range_cfg_input_CallInstance);
  Mock.nrf_gpio_range_cfg_input_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_range_cfg_input_CallInstance);
  if (Mock.nrf_gpio_range_cfg_input_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_range_cfg_input_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_range_cfg_input_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_range_cfg_input_CallbackBool &&
      Mock.nrf_gpio_range_cfg_input_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_range_cfg_input_CallbackFunctionPointer(pin_range_start, pin_range_end, pull_config, Mock.nrf_gpio_range_cfg_input_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_range_cfg_input,CMockString_pin_range_start);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_range_start, pin_range_start, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_range_cfg_input,CMockString_pin_range_end);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_range_end, pin_range_end, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_range_cfg_input,CMockString_pull_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pull_config), (void*)(&pull_config), sizeof(nrf_gpio_pin_pull_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_range_cfg_input_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_range_cfg_input_CallbackFunctionPointer(pin_range_start, pin_range_end, pull_config, Mock.nrf_gpio_range_cfg_input_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_range_cfg_input(CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE* cmock_call_instance, uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config);
void CMockExpectParameters_nrf_gpio_range_cfg_input(CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE* cmock_call_instance, uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config)
{
  cmock_call_instance->Expected_pin_range_start = pin_range_start;
  cmock_call_instance->Expected_pin_range_end = pin_range_end;
  memcpy((void*)(&cmock_call_instance->Expected_pull_config), (void*)(&pull_config),
         sizeof(nrf_gpio_pin_pull_t[sizeof(pull_config) == sizeof(nrf_gpio_pin_pull_t) ? 1 : -1])); /* add nrf_gpio_pin_pull_t to :treat_as_array if this causes an error */
}

void nrf_gpio_range_cfg_input_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE));
  CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_range_cfg_input_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_range_cfg_input_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_range_cfg_input_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_range_cfg_input_IgnoreBool = (char)1;
}

void nrf_gpio_range_cfg_input_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_range_cfg_input_IgnoreBool)
    Mock.nrf_gpio_range_cfg_input_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_range_cfg_input_CallInstance);
  Mock.nrf_gpio_range_cfg_input_IgnoreBool = (char)0;
}

void nrf_gpio_range_cfg_input_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE));
  CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_range_cfg_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_range_cfg_input_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_range_cfg_input_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_range_cfg_input_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_range_cfg_input(cmock_call_instance, pin_range_start, pin_range_end, pull_config);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_range_cfg_input_AddCallback(CMOCK_nrf_gpio_range_cfg_input_CALLBACK Callback)
{
  Mock.nrf_gpio_range_cfg_input_IgnoreBool = (char)0;
  Mock.nrf_gpio_range_cfg_input_CallbackBool = (char)1;
  Mock.nrf_gpio_range_cfg_input_CallbackFunctionPointer = Callback;
}

void nrf_gpio_range_cfg_input_Stub(CMOCK_nrf_gpio_range_cfg_input_CALLBACK Callback)
{
  Mock.nrf_gpio_range_cfg_input_IgnoreBool = (char)0;
  Mock.nrf_gpio_range_cfg_input_CallbackBool = (char)0;
  Mock.nrf_gpio_range_cfg_input_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_cfg(uint32_t pin_number, nrf_gpio_pin_dir_t dir, nrf_gpio_pin_input_t input, nrf_gpio_pin_pull_t pull, nrf_gpio_pin_drive_t drive, nrf_gpio_pin_sense_t sense)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_cfg_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg);
  cmock_call_instance = (CMOCK_nrf_gpio_cfg_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_cfg_CallInstance);
  Mock.nrf_gpio_cfg_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_CallInstance);
  if (Mock.nrf_gpio_cfg_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_cfg_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_cfg_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_cfg_CallbackBool &&
      Mock.nrf_gpio_cfg_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_cfg_CallbackFunctionPointer(pin_number, dir, input, pull, drive, sense, Mock.nrf_gpio_cfg_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(nrf_gpio_pin_dir_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg,CMockString_input);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input), (void*)(&input), sizeof(nrf_gpio_pin_input_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg,CMockString_pull);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pull), (void*)(&pull), sizeof(nrf_gpio_pin_pull_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg,CMockString_drive);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_drive), (void*)(&drive), sizeof(nrf_gpio_pin_drive_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg,CMockString_sense);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_sense), (void*)(&sense), sizeof(nrf_gpio_pin_sense_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_cfg_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_cfg_CallbackFunctionPointer(pin_number, dir, input, pull, drive, sense, Mock.nrf_gpio_cfg_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_cfg(CMOCK_nrf_gpio_cfg_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_dir_t dir, nrf_gpio_pin_input_t input, nrf_gpio_pin_pull_t pull, nrf_gpio_pin_drive_t drive, nrf_gpio_pin_sense_t sense);
void CMockExpectParameters_nrf_gpio_cfg(CMOCK_nrf_gpio_cfg_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_dir_t dir, nrf_gpio_pin_input_t input, nrf_gpio_pin_pull_t pull, nrf_gpio_pin_drive_t drive, nrf_gpio_pin_sense_t sense)
{
  cmock_call_instance->Expected_pin_number = pin_number;
  memcpy((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir),
         sizeof(nrf_gpio_pin_dir_t[sizeof(dir) == sizeof(nrf_gpio_pin_dir_t) ? 1 : -1])); /* add nrf_gpio_pin_dir_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_input), (void*)(&input),
         sizeof(nrf_gpio_pin_input_t[sizeof(input) == sizeof(nrf_gpio_pin_input_t) ? 1 : -1])); /* add nrf_gpio_pin_input_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_pull), (void*)(&pull),
         sizeof(nrf_gpio_pin_pull_t[sizeof(pull) == sizeof(nrf_gpio_pin_pull_t) ? 1 : -1])); /* add nrf_gpio_pin_pull_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_drive), (void*)(&drive),
         sizeof(nrf_gpio_pin_drive_t[sizeof(drive) == sizeof(nrf_gpio_pin_drive_t) ? 1 : -1])); /* add nrf_gpio_pin_drive_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_sense), (void*)(&sense),
         sizeof(nrf_gpio_pin_sense_t[sizeof(sense) == sizeof(nrf_gpio_pin_sense_t) ? 1 : -1])); /* add nrf_gpio_pin_sense_t to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_cfg_IgnoreBool = (char)1;
}

void nrf_gpio_cfg_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_cfg_IgnoreBool)
    Mock.nrf_gpio_cfg_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_CallInstance);
  Mock.nrf_gpio_cfg_IgnoreBool = (char)0;
}

void nrf_gpio_cfg_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, nrf_gpio_pin_dir_t dir, nrf_gpio_pin_input_t input, nrf_gpio_pin_pull_t pull, nrf_gpio_pin_drive_t drive, nrf_gpio_pin_sense_t sense, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_cfg(cmock_call_instance, pin_number, dir, input, pull, drive, sense);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_AddCallback(CMOCK_nrf_gpio_cfg_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_CallbackBool = (char)1;
  Mock.nrf_gpio_cfg_CallbackFunctionPointer = Callback;
}

void nrf_gpio_cfg_Stub(CMOCK_nrf_gpio_cfg_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_CallbackBool = (char)0;
  Mock.nrf_gpio_cfg_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_cfg_output(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_output);
  cmock_call_instance = (CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_cfg_output_CallInstance);
  Mock.nrf_gpio_cfg_output_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_output_CallInstance);
  if (Mock.nrf_gpio_cfg_output_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_cfg_output_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_cfg_output_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_cfg_output_CallbackBool &&
      Mock.nrf_gpio_cfg_output_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_cfg_output_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_cfg_output_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_output,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_cfg_output_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_cfg_output_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_cfg_output_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_cfg_output(CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_cfg_output(CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_cfg_output_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_output_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_output_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_output_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_cfg_output_IgnoreBool = (char)1;
}

void nrf_gpio_cfg_output_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_cfg_output_IgnoreBool)
    Mock.nrf_gpio_cfg_output_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_output_CallInstance);
  Mock.nrf_gpio_cfg_output_IgnoreBool = (char)0;
}

void nrf_gpio_cfg_output_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_output_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_output_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_output_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_output_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_cfg_output(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_output_AddCallback(CMOCK_nrf_gpio_cfg_output_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_output_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_output_CallbackBool = (char)1;
  Mock.nrf_gpio_cfg_output_CallbackFunctionPointer = Callback;
}

void nrf_gpio_cfg_output_Stub(CMOCK_nrf_gpio_cfg_output_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_output_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_output_CallbackBool = (char)0;
  Mock.nrf_gpio_cfg_output_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_input);
  cmock_call_instance = (CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_cfg_input_CallInstance);
  Mock.nrf_gpio_cfg_input_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_input_CallInstance);
  if (Mock.nrf_gpio_cfg_input_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_cfg_input_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_cfg_input_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_cfg_input_CallbackBool &&
      Mock.nrf_gpio_cfg_input_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_cfg_input_CallbackFunctionPointer(pin_number, pull_config, Mock.nrf_gpio_cfg_input_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_input,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_input,CMockString_pull_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pull_config), (void*)(&pull_config), sizeof(nrf_gpio_pin_pull_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_cfg_input_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_cfg_input_CallbackFunctionPointer(pin_number, pull_config, Mock.nrf_gpio_cfg_input_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_cfg_input(CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_pull_t pull_config);
void CMockExpectParameters_nrf_gpio_cfg_input(CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
{
  cmock_call_instance->Expected_pin_number = pin_number;
  memcpy((void*)(&cmock_call_instance->Expected_pull_config), (void*)(&pull_config),
         sizeof(nrf_gpio_pin_pull_t[sizeof(pull_config) == sizeof(nrf_gpio_pin_pull_t) ? 1 : -1])); /* add nrf_gpio_pin_pull_t to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_input_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_input_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_input_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_input_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_cfg_input_IgnoreBool = (char)1;
}

void nrf_gpio_cfg_input_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_cfg_input_IgnoreBool)
    Mock.nrf_gpio_cfg_input_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_input_CallInstance);
  Mock.nrf_gpio_cfg_input_IgnoreBool = (char)0;
}

void nrf_gpio_cfg_input_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_input_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_input_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_input_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_cfg_input(cmock_call_instance, pin_number, pull_config);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_input_AddCallback(CMOCK_nrf_gpio_cfg_input_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_input_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_input_CallbackBool = (char)1;
  Mock.nrf_gpio_cfg_input_CallbackFunctionPointer = Callback;
}

void nrf_gpio_cfg_input_Stub(CMOCK_nrf_gpio_cfg_input_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_input_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_input_CallbackBool = (char)0;
  Mock.nrf_gpio_cfg_input_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_cfg_default(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_default);
  cmock_call_instance = (CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_cfg_default_CallInstance);
  Mock.nrf_gpio_cfg_default_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_default_CallInstance);
  if (Mock.nrf_gpio_cfg_default_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_cfg_default_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_cfg_default_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_cfg_default_CallbackBool &&
      Mock.nrf_gpio_cfg_default_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_cfg_default_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_cfg_default_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_default,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_cfg_default_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_cfg_default_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_cfg_default_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_cfg_default(CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_cfg_default(CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_cfg_default_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_default_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_default_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_default_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_cfg_default_IgnoreBool = (char)1;
}

void nrf_gpio_cfg_default_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_cfg_default_IgnoreBool)
    Mock.nrf_gpio_cfg_default_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_default_CallInstance);
  Mock.nrf_gpio_cfg_default_IgnoreBool = (char)0;
}

void nrf_gpio_cfg_default_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_default_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_default_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_default_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_default_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_cfg_default(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_default_AddCallback(CMOCK_nrf_gpio_cfg_default_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_default_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_default_CallbackBool = (char)1;
  Mock.nrf_gpio_cfg_default_CallbackFunctionPointer = Callback;
}

void nrf_gpio_cfg_default_Stub(CMOCK_nrf_gpio_cfg_default_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_default_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_default_CallbackBool = (char)0;
  Mock.nrf_gpio_cfg_default_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_cfg_watcher(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_watcher);
  cmock_call_instance = (CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_cfg_watcher_CallInstance);
  Mock.nrf_gpio_cfg_watcher_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_watcher_CallInstance);
  if (Mock.nrf_gpio_cfg_watcher_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_cfg_watcher_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_cfg_watcher_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_cfg_watcher_CallbackBool &&
      Mock.nrf_gpio_cfg_watcher_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_cfg_watcher_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_cfg_watcher_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_watcher,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_cfg_watcher_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_cfg_watcher_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_cfg_watcher_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_cfg_watcher(CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_cfg_watcher(CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_cfg_watcher_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_watcher_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_watcher_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_watcher_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_cfg_watcher_IgnoreBool = (char)1;
}

void nrf_gpio_cfg_watcher_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_cfg_watcher_IgnoreBool)
    Mock.nrf_gpio_cfg_watcher_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_watcher_CallInstance);
  Mock.nrf_gpio_cfg_watcher_IgnoreBool = (char)0;
}

void nrf_gpio_cfg_watcher_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_watcher_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_watcher_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_watcher_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_watcher_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_cfg_watcher(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_watcher_AddCallback(CMOCK_nrf_gpio_cfg_watcher_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_watcher_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_watcher_CallbackBool = (char)1;
  Mock.nrf_gpio_cfg_watcher_CallbackFunctionPointer = Callback;
}

void nrf_gpio_cfg_watcher_Stub(CMOCK_nrf_gpio_cfg_watcher_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_watcher_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_watcher_CallbackBool = (char)0;
  Mock.nrf_gpio_cfg_watcher_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_input_disconnect(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_input_disconnect);
  cmock_call_instance = (CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_input_disconnect_CallInstance);
  Mock.nrf_gpio_input_disconnect_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_input_disconnect_CallInstance);
  if (Mock.nrf_gpio_input_disconnect_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_input_disconnect_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_input_disconnect_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_input_disconnect_CallbackBool &&
      Mock.nrf_gpio_input_disconnect_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_input_disconnect_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_input_disconnect_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_input_disconnect,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_input_disconnect_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_input_disconnect_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_input_disconnect_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_input_disconnect(CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_input_disconnect(CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_input_disconnect_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE));
  CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_input_disconnect_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_input_disconnect_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_input_disconnect_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_input_disconnect_IgnoreBool = (char)1;
}

void nrf_gpio_input_disconnect_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_input_disconnect_IgnoreBool)
    Mock.nrf_gpio_input_disconnect_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_input_disconnect_CallInstance);
  Mock.nrf_gpio_input_disconnect_IgnoreBool = (char)0;
}

void nrf_gpio_input_disconnect_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE));
  CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_input_disconnect_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_input_disconnect_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_input_disconnect_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_input_disconnect_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_input_disconnect(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_input_disconnect_AddCallback(CMOCK_nrf_gpio_input_disconnect_CALLBACK Callback)
{
  Mock.nrf_gpio_input_disconnect_IgnoreBool = (char)0;
  Mock.nrf_gpio_input_disconnect_CallbackBool = (char)1;
  Mock.nrf_gpio_input_disconnect_CallbackFunctionPointer = Callback;
}

void nrf_gpio_input_disconnect_Stub(CMOCK_nrf_gpio_input_disconnect_CALLBACK Callback)
{
  Mock.nrf_gpio_input_disconnect_IgnoreBool = (char)0;
  Mock.nrf_gpio_input_disconnect_CallbackBool = (char)0;
  Mock.nrf_gpio_input_disconnect_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_cfg_sense_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_sense_input);
  cmock_call_instance = (CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_cfg_sense_input_CallInstance);
  Mock.nrf_gpio_cfg_sense_input_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_sense_input_CallInstance);
  if (Mock.nrf_gpio_cfg_sense_input_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_cfg_sense_input_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_cfg_sense_input_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_cfg_sense_input_CallbackBool &&
      Mock.nrf_gpio_cfg_sense_input_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_cfg_sense_input_CallbackFunctionPointer(pin_number, pull_config, sense_config, Mock.nrf_gpio_cfg_sense_input_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_sense_input,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_sense_input,CMockString_pull_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pull_config), (void*)(&pull_config), sizeof(nrf_gpio_pin_pull_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_sense_input,CMockString_sense_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_sense_config), (void*)(&sense_config), sizeof(nrf_gpio_pin_sense_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_cfg_sense_input_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_cfg_sense_input_CallbackFunctionPointer(pin_number, pull_config, sense_config, Mock.nrf_gpio_cfg_sense_input_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_cfg_sense_input(CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config);
void CMockExpectParameters_nrf_gpio_cfg_sense_input(CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config)
{
  cmock_call_instance->Expected_pin_number = pin_number;
  memcpy((void*)(&cmock_call_instance->Expected_pull_config), (void*)(&pull_config),
         sizeof(nrf_gpio_pin_pull_t[sizeof(pull_config) == sizeof(nrf_gpio_pin_pull_t) ? 1 : -1])); /* add nrf_gpio_pin_pull_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_sense_config), (void*)(&sense_config),
         sizeof(nrf_gpio_pin_sense_t[sizeof(sense_config) == sizeof(nrf_gpio_pin_sense_t) ? 1 : -1])); /* add nrf_gpio_pin_sense_t to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_sense_input_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_sense_input_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_sense_input_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_sense_input_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_cfg_sense_input_IgnoreBool = (char)1;
}

void nrf_gpio_cfg_sense_input_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_cfg_sense_input_IgnoreBool)
    Mock.nrf_gpio_cfg_sense_input_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_sense_input_CallInstance);
  Mock.nrf_gpio_cfg_sense_input_IgnoreBool = (char)0;
}

void nrf_gpio_cfg_sense_input_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, nrf_gpio_pin_pull_t pull_config, nrf_gpio_pin_sense_t sense_config, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_sense_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_sense_input_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_sense_input_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_sense_input_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_cfg_sense_input(cmock_call_instance, pin_number, pull_config, sense_config);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_sense_input_AddCallback(CMOCK_nrf_gpio_cfg_sense_input_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_sense_input_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_sense_input_CallbackBool = (char)1;
  Mock.nrf_gpio_cfg_sense_input_CallbackFunctionPointer = Callback;
}

void nrf_gpio_cfg_sense_input_Stub(CMOCK_nrf_gpio_cfg_sense_input_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_sense_input_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_sense_input_CallbackBool = (char)0;
  Mock.nrf_gpio_cfg_sense_input_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_cfg_sense_set);
  cmock_call_instance = (CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_cfg_sense_set_CallInstance);
  Mock.nrf_gpio_cfg_sense_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_sense_set_CallInstance);
  if (Mock.nrf_gpio_cfg_sense_set_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_cfg_sense_set_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_cfg_sense_set_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_cfg_sense_set_CallbackBool &&
      Mock.nrf_gpio_cfg_sense_set_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_cfg_sense_set_CallbackFunctionPointer(pin_number, sense_config, Mock.nrf_gpio_cfg_sense_set_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_sense_set,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_cfg_sense_set,CMockString_sense_config);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_sense_config), (void*)(&sense_config), sizeof(nrf_gpio_pin_sense_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_cfg_sense_set_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_cfg_sense_set_CallbackFunctionPointer(pin_number, sense_config, Mock.nrf_gpio_cfg_sense_set_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_cfg_sense_set(CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_sense_t sense_config);
void CMockExpectParameters_nrf_gpio_cfg_sense_set(CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
{
  cmock_call_instance->Expected_pin_number = pin_number;
  memcpy((void*)(&cmock_call_instance->Expected_sense_config), (void*)(&sense_config),
         sizeof(nrf_gpio_pin_sense_t[sizeof(sense_config) == sizeof(nrf_gpio_pin_sense_t) ? 1 : -1])); /* add nrf_gpio_pin_sense_t to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_sense_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_sense_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_sense_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_sense_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_cfg_sense_set_IgnoreBool = (char)1;
}

void nrf_gpio_cfg_sense_set_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_cfg_sense_set_IgnoreBool)
    Mock.nrf_gpio_cfg_sense_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_cfg_sense_set_CallInstance);
  Mock.nrf_gpio_cfg_sense_set_IgnoreBool = (char)0;
}

void nrf_gpio_cfg_sense_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, nrf_gpio_pin_sense_t sense_config, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_cfg_sense_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_cfg_sense_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_cfg_sense_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_cfg_sense_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_cfg_sense_set(cmock_call_instance, pin_number, sense_config);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_cfg_sense_set_AddCallback(CMOCK_nrf_gpio_cfg_sense_set_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_sense_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_sense_set_CallbackBool = (char)1;
  Mock.nrf_gpio_cfg_sense_set_CallbackFunctionPointer = Callback;
}

void nrf_gpio_cfg_sense_set_Stub(CMOCK_nrf_gpio_cfg_sense_set_CALLBACK Callback)
{
  Mock.nrf_gpio_cfg_sense_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_cfg_sense_set_CallbackBool = (char)0;
  Mock.nrf_gpio_cfg_sense_set_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_dir_set);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_dir_set_CallInstance);
  Mock.nrf_gpio_pin_dir_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_dir_set_CallInstance);
  if (Mock.nrf_gpio_pin_dir_set_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_dir_set_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_dir_set_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_dir_set_CallbackBool &&
      Mock.nrf_gpio_pin_dir_set_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_pin_dir_set_CallbackFunctionPointer(pin_number, direction, Mock.nrf_gpio_pin_dir_set_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_dir_set,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_dir_set,CMockString_direction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_direction), (void*)(&direction), sizeof(nrf_gpio_pin_dir_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_dir_set_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_dir_set_CallbackFunctionPointer(pin_number, direction, Mock.nrf_gpio_pin_dir_set_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_dir_set(CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_dir_t direction);
void CMockExpectParameters_nrf_gpio_pin_dir_set(CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, nrf_gpio_pin_dir_t direction)
{
  cmock_call_instance->Expected_pin_number = pin_number;
  memcpy((void*)(&cmock_call_instance->Expected_direction), (void*)(&direction),
         sizeof(nrf_gpio_pin_dir_t[sizeof(direction) == sizeof(nrf_gpio_pin_dir_t) ? 1 : -1])); /* add nrf_gpio_pin_dir_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_dir_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_dir_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_dir_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_dir_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_dir_set_IgnoreBool = (char)1;
}

void nrf_gpio_pin_dir_set_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_dir_set_IgnoreBool)
    Mock.nrf_gpio_pin_dir_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_dir_set_CallInstance);
  Mock.nrf_gpio_pin_dir_set_IgnoreBool = (char)0;
}

void nrf_gpio_pin_dir_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, nrf_gpio_pin_dir_t direction, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_dir_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_dir_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_dir_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_dir_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_dir_set(cmock_call_instance, pin_number, direction);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_dir_set_AddCallback(CMOCK_nrf_gpio_pin_dir_set_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_dir_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_dir_set_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_dir_set_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_dir_set_Stub(CMOCK_nrf_gpio_pin_dir_set_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_dir_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_dir_set_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_dir_set_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_pin_set(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_set_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_set);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_set_CallInstance);
  Mock.nrf_gpio_pin_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_set_CallInstance);
  if (Mock.nrf_gpio_pin_set_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_set_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_set_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_set_CallbackBool &&
      Mock.nrf_gpio_pin_set_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_pin_set_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_set_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_set,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_set_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_set_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_set_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_set(CMOCK_nrf_gpio_pin_set_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_set(CMOCK_nrf_gpio_pin_set_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_set_IgnoreBool = (char)1;
}

void nrf_gpio_pin_set_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_set_IgnoreBool)
    Mock.nrf_gpio_pin_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_set_CallInstance);
  Mock.nrf_gpio_pin_set_IgnoreBool = (char)0;
}

void nrf_gpio_pin_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_set(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_set_AddCallback(CMOCK_nrf_gpio_pin_set_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_set_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_set_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_set_Stub(CMOCK_nrf_gpio_pin_set_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_set_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_set_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_pin_clear(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_clear);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_clear_CallInstance);
  Mock.nrf_gpio_pin_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_clear_CallInstance);
  if (Mock.nrf_gpio_pin_clear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_clear_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_clear_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_clear_CallbackBool &&
      Mock.nrf_gpio_pin_clear_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_pin_clear_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_clear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_clear,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_clear_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_clear_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_clear_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_clear(CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_clear(CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_clear_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_clear_IgnoreBool = (char)1;
}

void nrf_gpio_pin_clear_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_clear_IgnoreBool)
    Mock.nrf_gpio_pin_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_clear_CallInstance);
  Mock.nrf_gpio_pin_clear_IgnoreBool = (char)0;
}

void nrf_gpio_pin_clear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_clear(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_clear_AddCallback(CMOCK_nrf_gpio_pin_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_clear_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_clear_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_clear_Stub(CMOCK_nrf_gpio_pin_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_clear_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_clear_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_pin_toggle(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_toggle);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_toggle_CallInstance);
  Mock.nrf_gpio_pin_toggle_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_toggle_CallInstance);
  if (Mock.nrf_gpio_pin_toggle_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_toggle_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_toggle_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_toggle_CallbackBool &&
      Mock.nrf_gpio_pin_toggle_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_pin_toggle_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_toggle_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_toggle,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_toggle_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_toggle_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_toggle_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_toggle(CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_toggle(CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_toggle_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_toggle_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_toggle_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_toggle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_toggle_IgnoreBool = (char)1;
}

void nrf_gpio_pin_toggle_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_toggle_IgnoreBool)
    Mock.nrf_gpio_pin_toggle_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_toggle_CallInstance);
  Mock.nrf_gpio_pin_toggle_IgnoreBool = (char)0;
}

void nrf_gpio_pin_toggle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_toggle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_toggle_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_toggle_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_toggle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_toggle(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_toggle_AddCallback(CMOCK_nrf_gpio_pin_toggle_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_toggle_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_toggle_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_toggle_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_toggle_Stub(CMOCK_nrf_gpio_pin_toggle_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_toggle_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_toggle_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_toggle_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_write_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_write);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_write_CallInstance);
  Mock.nrf_gpio_pin_write_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_write_CallInstance);
  if (Mock.nrf_gpio_pin_write_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_write_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_write_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_write_CallbackBool &&
      Mock.nrf_gpio_pin_write_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_pin_write_CallbackFunctionPointer(pin_number, value, Mock.nrf_gpio_pin_write_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_write,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_write,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_write_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_write_CallbackFunctionPointer(pin_number, value, Mock.nrf_gpio_pin_write_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_write(CMOCK_nrf_gpio_pin_write_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, uint32_t value);
void CMockExpectParameters_nrf_gpio_pin_write(CMOCK_nrf_gpio_pin_write_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number, uint32_t value)
{
  cmock_call_instance->Expected_pin_number = pin_number;
  cmock_call_instance->Expected_value = value;
}

void nrf_gpio_pin_write_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_write_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_write_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_write_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_write_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_write_IgnoreBool = (char)1;
}

void nrf_gpio_pin_write_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_write_IgnoreBool)
    Mock.nrf_gpio_pin_write_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_write_CallInstance);
  Mock.nrf_gpio_pin_write_IgnoreBool = (char)0;
}

void nrf_gpio_pin_write_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, uint32_t value, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_write_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_write_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_write_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_write_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_write(cmock_call_instance, pin_number, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_write_AddCallback(CMOCK_nrf_gpio_pin_write_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_write_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_write_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_write_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_write_Stub(CMOCK_nrf_gpio_pin_write_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_write_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_write_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_write_CallbackFunctionPointer = Callback;
}

inluce uint32_t nrf_gpio_pin_read(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_read_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_read);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_read_CallInstance);
  Mock.nrf_gpio_pin_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_read_CallInstance);
  if (Mock.nrf_gpio_pin_read_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_read_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_read_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce uint32_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_read_CallbackBool &&
      Mock.nrf_gpio_pin_read_CallbackFunctionPointer != NULL)
  {
    inluce uint32_t cmock_cb_ret = Mock.nrf_gpio_pin_read_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_read_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_read,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_read_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_read_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_read_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_read(CMOCK_nrf_gpio_pin_read_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_read(CMOCK_nrf_gpio_pin_read_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_read_IgnoreBool = (char)1;
}

void nrf_gpio_pin_read_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_read_IgnoreBool)
    Mock.nrf_gpio_pin_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_read_CallInstance);
  Mock.nrf_gpio_pin_read_IgnoreBool = (char)0;
}

void nrf_gpio_pin_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_read(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce uint32_t[sizeof(cmock_to_return) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_read_AddCallback(CMOCK_nrf_gpio_pin_read_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_read_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_read_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_read_Stub(CMOCK_nrf_gpio_pin_read_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_read_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_read_CallbackFunctionPointer = Callback;
}

inluce uint32_t nrf_gpio_pin_out_read(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_out_read);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_out_read_CallInstance);
  Mock.nrf_gpio_pin_out_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_out_read_CallInstance);
  if (Mock.nrf_gpio_pin_out_read_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_out_read_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_out_read_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce uint32_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_out_read_CallbackBool &&
      Mock.nrf_gpio_pin_out_read_CallbackFunctionPointer != NULL)
  {
    inluce uint32_t cmock_cb_ret = Mock.nrf_gpio_pin_out_read_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_out_read_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_out_read,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_out_read_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_out_read_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_out_read_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_out_read(CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_out_read(CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_out_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_out_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_out_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_out_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_out_read_IgnoreBool = (char)1;
}

void nrf_gpio_pin_out_read_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_out_read_IgnoreBool)
    Mock.nrf_gpio_pin_out_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_out_read_CallInstance);
  Mock.nrf_gpio_pin_out_read_IgnoreBool = (char)0;
}

void nrf_gpio_pin_out_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_out_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_out_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_out_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_out_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_out_read(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce uint32_t[sizeof(cmock_to_return) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_out_read_AddCallback(CMOCK_nrf_gpio_pin_out_read_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_out_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_out_read_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_out_read_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_out_read_Stub(CMOCK_nrf_gpio_pin_out_read_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_out_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_out_read_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_out_read_CallbackFunctionPointer = Callback;
}

inluce nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_sense_get);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_sense_get_CallInstance);
  Mock.nrf_gpio_pin_sense_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_sense_get_CallInstance);
  if (Mock.nrf_gpio_pin_sense_get_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_sense_get_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_sense_get_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce nrf_gpio_pin_sense_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce nrf_gpio_pin_sense_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_sense_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_sense_get_CallbackBool &&
      Mock.nrf_gpio_pin_sense_get_CallbackFunctionPointer != NULL)
  {
    inluce nrf_gpio_pin_sense_t cmock_cb_ret = Mock.nrf_gpio_pin_sense_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_sense_get_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_sense_get,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_sense_get_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_sense_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_sense_get_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_sense_get(CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_sense_get(CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_sense_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce nrf_gpio_pin_sense_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_sense_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_sense_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_sense_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_sense_get_IgnoreBool = (char)1;
}

void nrf_gpio_pin_sense_get_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_sense_get_IgnoreBool)
    Mock.nrf_gpio_pin_sense_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_sense_get_CallInstance);
  Mock.nrf_gpio_pin_sense_get_IgnoreBool = (char)0;
}

void nrf_gpio_pin_sense_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce nrf_gpio_pin_sense_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_sense_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_sense_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_sense_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_sense_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_sense_get(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce nrf_gpio_pin_sense_t[sizeof(cmock_to_return) == sizeof(inluce nrf_gpio_pin_sense_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_sense_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_sense_get_AddCallback(CMOCK_nrf_gpio_pin_sense_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_sense_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_sense_get_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_sense_get_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_sense_get_Stub(CMOCK_nrf_gpio_pin_sense_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_sense_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_sense_get_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_sense_get_CallbackFunctionPointer = Callback;
}

inluce nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_dir_get);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_dir_get_CallInstance);
  Mock.nrf_gpio_pin_dir_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_dir_get_CallInstance);
  if (Mock.nrf_gpio_pin_dir_get_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_dir_get_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_dir_get_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce nrf_gpio_pin_dir_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce nrf_gpio_pin_dir_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_dir_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_dir_get_CallbackBool &&
      Mock.nrf_gpio_pin_dir_get_CallbackFunctionPointer != NULL)
  {
    inluce nrf_gpio_pin_dir_t cmock_cb_ret = Mock.nrf_gpio_pin_dir_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_dir_get_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_dir_get,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_dir_get_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_dir_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_dir_get_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_dir_get(CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_dir_get(CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_dir_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce nrf_gpio_pin_dir_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_dir_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_dir_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_dir_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_dir_get_IgnoreBool = (char)1;
}

void nrf_gpio_pin_dir_get_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_dir_get_IgnoreBool)
    Mock.nrf_gpio_pin_dir_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_dir_get_CallInstance);
  Mock.nrf_gpio_pin_dir_get_IgnoreBool = (char)0;
}

void nrf_gpio_pin_dir_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce nrf_gpio_pin_dir_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_dir_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_dir_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_dir_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_dir_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_dir_get(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce nrf_gpio_pin_dir_t[sizeof(cmock_to_return) == sizeof(inluce nrf_gpio_pin_dir_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_dir_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_dir_get_AddCallback(CMOCK_nrf_gpio_pin_dir_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_dir_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_dir_get_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_dir_get_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_dir_get_Stub(CMOCK_nrf_gpio_pin_dir_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_dir_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_dir_get_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_dir_get_CallbackFunctionPointer = Callback;
}

inluce nrf_gpio_pin_input_t nrf_gpio_pin_input_get(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_input_get);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_input_get_CallInstance);
  Mock.nrf_gpio_pin_input_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_input_get_CallInstance);
  if (Mock.nrf_gpio_pin_input_get_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_input_get_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_input_get_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce nrf_gpio_pin_input_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce nrf_gpio_pin_input_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_input_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_input_get_CallbackBool &&
      Mock.nrf_gpio_pin_input_get_CallbackFunctionPointer != NULL)
  {
    inluce nrf_gpio_pin_input_t cmock_cb_ret = Mock.nrf_gpio_pin_input_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_input_get_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_input_get,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_input_get_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_input_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_input_get_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_input_get(CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_input_get(CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_input_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce nrf_gpio_pin_input_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_input_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_input_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_input_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_input_get_IgnoreBool = (char)1;
}

void nrf_gpio_pin_input_get_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_input_get_IgnoreBool)
    Mock.nrf_gpio_pin_input_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_input_get_CallInstance);
  Mock.nrf_gpio_pin_input_get_IgnoreBool = (char)0;
}

void nrf_gpio_pin_input_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce nrf_gpio_pin_input_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_input_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_input_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_input_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_input_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_input_get(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce nrf_gpio_pin_input_t[sizeof(cmock_to_return) == sizeof(inluce nrf_gpio_pin_input_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_input_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_input_get_AddCallback(CMOCK_nrf_gpio_pin_input_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_input_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_input_get_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_input_get_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_input_get_Stub(CMOCK_nrf_gpio_pin_input_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_input_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_input_get_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_input_get_CallbackFunctionPointer = Callback;
}

inluce nrf_gpio_pin_pull_t nrf_gpio_pin_pull_get(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_pull_get);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_pull_get_CallInstance);
  Mock.nrf_gpio_pin_pull_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_pull_get_CallInstance);
  if (Mock.nrf_gpio_pin_pull_get_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_pull_get_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_pull_get_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce nrf_gpio_pin_pull_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce nrf_gpio_pin_pull_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_pull_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_pull_get_CallbackBool &&
      Mock.nrf_gpio_pin_pull_get_CallbackFunctionPointer != NULL)
  {
    inluce nrf_gpio_pin_pull_t cmock_cb_ret = Mock.nrf_gpio_pin_pull_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_pull_get_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_pull_get,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_pull_get_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_pull_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_pull_get_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_pull_get(CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_pull_get(CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_pull_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce nrf_gpio_pin_pull_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_pull_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_pull_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_pull_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_pull_get_IgnoreBool = (char)1;
}

void nrf_gpio_pin_pull_get_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_pull_get_IgnoreBool)
    Mock.nrf_gpio_pin_pull_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_pull_get_CallInstance);
  Mock.nrf_gpio_pin_pull_get_IgnoreBool = (char)0;
}

void nrf_gpio_pin_pull_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce nrf_gpio_pin_pull_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_pull_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_pull_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_pull_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_pull_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_pull_get(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce nrf_gpio_pin_pull_t[sizeof(cmock_to_return) == sizeof(inluce nrf_gpio_pin_pull_t) ? 1 : -1])); /* add inluce nrf_gpio_pin_pull_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_pull_get_AddCallback(CMOCK_nrf_gpio_pin_pull_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_pull_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_pull_get_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_pull_get_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_pull_get_Stub(CMOCK_nrf_gpio_pin_pull_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_pull_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_pull_get_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_pull_get_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_port_dir_output_set(NRF_GPIO_Type* p_reg, uint32_t out_mask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_output_set);
  cmock_call_instance = (CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_dir_output_set_CallInstance);
  Mock.nrf_gpio_port_dir_output_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_output_set_CallInstance);
  if (Mock.nrf_gpio_port_dir_output_set_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_dir_output_set_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_dir_output_set_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_dir_output_set_CallbackBool &&
      Mock.nrf_gpio_port_dir_output_set_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_port_dir_output_set_CallbackFunctionPointer(p_reg, out_mask, Mock.nrf_gpio_port_dir_output_set_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_dir_output_set,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_dir_output_set,CMockString_out_mask);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_out_mask, out_mask, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_dir_output_set_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_dir_output_set_CallbackFunctionPointer(p_reg, out_mask, Mock.nrf_gpio_port_dir_output_set_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_dir_output_set(CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t out_mask);
void CMockExpectParameters_nrf_gpio_port_dir_output_set(CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t out_mask)
{
  cmock_call_instance->Expected_p_reg = p_reg;
  cmock_call_instance->Expected_out_mask = out_mask;
}

void nrf_gpio_port_dir_output_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_output_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_output_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_output_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_dir_output_set_IgnoreBool = (char)1;
}

void nrf_gpio_port_dir_output_set_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_dir_output_set_IgnoreBool)
    Mock.nrf_gpio_port_dir_output_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_output_set_CallInstance);
  Mock.nrf_gpio_port_dir_output_set_IgnoreBool = (char)0;
}

void nrf_gpio_port_dir_output_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type* p_reg, uint32_t out_mask, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_output_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_output_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_output_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_output_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_dir_output_set(cmock_call_instance, p_reg, out_mask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_port_dir_output_set_AddCallback(CMOCK_nrf_gpio_port_dir_output_set_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_output_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_output_set_CallbackBool = (char)1;
  Mock.nrf_gpio_port_dir_output_set_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_dir_output_set_Stub(CMOCK_nrf_gpio_port_dir_output_set_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_output_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_output_set_CallbackBool = (char)0;
  Mock.nrf_gpio_port_dir_output_set_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_port_dir_input_set(NRF_GPIO_Type* p_reg, uint32_t in_mask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_input_set);
  cmock_call_instance = (CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_dir_input_set_CallInstance);
  Mock.nrf_gpio_port_dir_input_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_input_set_CallInstance);
  if (Mock.nrf_gpio_port_dir_input_set_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_dir_input_set_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_dir_input_set_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_dir_input_set_CallbackBool &&
      Mock.nrf_gpio_port_dir_input_set_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_port_dir_input_set_CallbackFunctionPointer(p_reg, in_mask, Mock.nrf_gpio_port_dir_input_set_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_dir_input_set,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_dir_input_set,CMockString_in_mask);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_in_mask, in_mask, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_dir_input_set_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_dir_input_set_CallbackFunctionPointer(p_reg, in_mask, Mock.nrf_gpio_port_dir_input_set_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_dir_input_set(CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t in_mask);
void CMockExpectParameters_nrf_gpio_port_dir_input_set(CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t in_mask)
{
  cmock_call_instance->Expected_p_reg = p_reg;
  cmock_call_instance->Expected_in_mask = in_mask;
}

void nrf_gpio_port_dir_input_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_input_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_input_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_input_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_dir_input_set_IgnoreBool = (char)1;
}

void nrf_gpio_port_dir_input_set_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_dir_input_set_IgnoreBool)
    Mock.nrf_gpio_port_dir_input_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_input_set_CallInstance);
  Mock.nrf_gpio_port_dir_input_set_IgnoreBool = (char)0;
}

void nrf_gpio_port_dir_input_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type* p_reg, uint32_t in_mask, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_input_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_input_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_input_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_input_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_dir_input_set(cmock_call_instance, p_reg, in_mask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_port_dir_input_set_AddCallback(CMOCK_nrf_gpio_port_dir_input_set_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_input_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_input_set_CallbackBool = (char)1;
  Mock.nrf_gpio_port_dir_input_set_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_dir_input_set_Stub(CMOCK_nrf_gpio_port_dir_input_set_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_input_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_input_set_CallbackBool = (char)0;
  Mock.nrf_gpio_port_dir_input_set_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_port_dir_write(NRF_GPIO_Type* p_reg, uint32_t dir_mask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_write);
  cmock_call_instance = (CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_dir_write_CallInstance);
  Mock.nrf_gpio_port_dir_write_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_write_CallInstance);
  if (Mock.nrf_gpio_port_dir_write_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_dir_write_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_dir_write_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_dir_write_CallbackBool &&
      Mock.nrf_gpio_port_dir_write_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_port_dir_write_CallbackFunctionPointer(p_reg, dir_mask, Mock.nrf_gpio_port_dir_write_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_dir_write,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_dir_write,CMockString_dir_mask);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_dir_mask, dir_mask, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_dir_write_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_dir_write_CallbackFunctionPointer(p_reg, dir_mask, Mock.nrf_gpio_port_dir_write_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_dir_write(CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t dir_mask);
void CMockExpectParameters_nrf_gpio_port_dir_write(CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t dir_mask)
{
  cmock_call_instance->Expected_p_reg = p_reg;
  cmock_call_instance->Expected_dir_mask = dir_mask;
}

void nrf_gpio_port_dir_write_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_write_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_write_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_write_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_dir_write_IgnoreBool = (char)1;
}

void nrf_gpio_port_dir_write_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_dir_write_IgnoreBool)
    Mock.nrf_gpio_port_dir_write_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_write_CallInstance);
  Mock.nrf_gpio_port_dir_write_IgnoreBool = (char)0;
}

void nrf_gpio_port_dir_write_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type* p_reg, uint32_t dir_mask, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_write_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_write_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_write_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_dir_write(cmock_call_instance, p_reg, dir_mask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_port_dir_write_AddCallback(CMOCK_nrf_gpio_port_dir_write_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_write_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_write_CallbackBool = (char)1;
  Mock.nrf_gpio_port_dir_write_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_dir_write_Stub(CMOCK_nrf_gpio_port_dir_write_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_write_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_write_CallbackBool = (char)0;
  Mock.nrf_gpio_port_dir_write_CallbackFunctionPointer = Callback;
}

inluce uint32_t nrf_gpio_port_dir_read(NRF_GPIO_Type const* p_reg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_dir_read);
  cmock_call_instance = (CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_dir_read_CallInstance);
  Mock.nrf_gpio_port_dir_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_read_CallInstance);
  if (Mock.nrf_gpio_port_dir_read_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_dir_read_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_dir_read_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce uint32_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_dir_read_CallbackBool &&
      Mock.nrf_gpio_port_dir_read_CallbackFunctionPointer != NULL)
  {
    inluce uint32_t cmock_cb_ret = Mock.nrf_gpio_port_dir_read_CallbackFunctionPointer(p_reg, Mock.nrf_gpio_port_dir_read_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_dir_read,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type const), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_dir_read_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_dir_read_CallbackFunctionPointer(p_reg, Mock.nrf_gpio_port_dir_read_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_dir_read(CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type const* p_reg);
void CMockExpectParameters_nrf_gpio_port_dir_read(CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type const* p_reg)
{
  cmock_call_instance->Expected_p_reg = p_reg;
}

void nrf_gpio_port_dir_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_dir_read_IgnoreBool = (char)1;
}

void nrf_gpio_port_dir_read_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_dir_read_IgnoreBool)
    Mock.nrf_gpio_port_dir_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_dir_read_CallInstance);
  Mock.nrf_gpio_port_dir_read_IgnoreBool = (char)0;
}

void nrf_gpio_port_dir_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type const* p_reg, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_dir_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_dir_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_dir_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_dir_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_dir_read(cmock_call_instance, p_reg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce uint32_t[sizeof(cmock_to_return) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
}

void nrf_gpio_port_dir_read_AddCallback(CMOCK_nrf_gpio_port_dir_read_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_read_CallbackBool = (char)1;
  Mock.nrf_gpio_port_dir_read_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_dir_read_Stub(CMOCK_nrf_gpio_port_dir_read_CALLBACK Callback)
{
  Mock.nrf_gpio_port_dir_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_dir_read_CallbackBool = (char)0;
  Mock.nrf_gpio_port_dir_read_CallbackFunctionPointer = Callback;
}

inluce uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const* p_reg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_in_read);
  cmock_call_instance = (CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_in_read_CallInstance);
  Mock.nrf_gpio_port_in_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_in_read_CallInstance);
  if (Mock.nrf_gpio_port_in_read_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_in_read_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_in_read_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce uint32_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_in_read_CallbackBool &&
      Mock.nrf_gpio_port_in_read_CallbackFunctionPointer != NULL)
  {
    inluce uint32_t cmock_cb_ret = Mock.nrf_gpio_port_in_read_CallbackFunctionPointer(p_reg, Mock.nrf_gpio_port_in_read_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_in_read,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type const), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_in_read_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_in_read_CallbackFunctionPointer(p_reg, Mock.nrf_gpio_port_in_read_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_in_read(CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type const* p_reg);
void CMockExpectParameters_nrf_gpio_port_in_read(CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type const* p_reg)
{
  cmock_call_instance->Expected_p_reg = p_reg;
}

void nrf_gpio_port_in_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_in_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_in_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_in_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_in_read_IgnoreBool = (char)1;
}

void nrf_gpio_port_in_read_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_in_read_IgnoreBool)
    Mock.nrf_gpio_port_in_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_in_read_CallInstance);
  Mock.nrf_gpio_port_in_read_IgnoreBool = (char)0;
}

void nrf_gpio_port_in_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type const* p_reg, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_in_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_in_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_in_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_in_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_in_read(cmock_call_instance, p_reg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce uint32_t[sizeof(cmock_to_return) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
}

void nrf_gpio_port_in_read_AddCallback(CMOCK_nrf_gpio_port_in_read_CALLBACK Callback)
{
  Mock.nrf_gpio_port_in_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_in_read_CallbackBool = (char)1;
  Mock.nrf_gpio_port_in_read_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_in_read_Stub(CMOCK_nrf_gpio_port_in_read_CALLBACK Callback)
{
  Mock.nrf_gpio_port_in_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_in_read_CallbackBool = (char)0;
  Mock.nrf_gpio_port_in_read_CallbackFunctionPointer = Callback;
}

inluce uint32_t nrf_gpio_port_out_read(NRF_GPIO_Type const* p_reg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_read);
  cmock_call_instance = (CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_out_read_CallInstance);
  Mock.nrf_gpio_port_out_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_read_CallInstance);
  if (Mock.nrf_gpio_port_out_read_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_out_read_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_out_read_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce uint32_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_out_read_CallbackBool &&
      Mock.nrf_gpio_port_out_read_CallbackFunctionPointer != NULL)
  {
    inluce uint32_t cmock_cb_ret = Mock.nrf_gpio_port_out_read_CallbackFunctionPointer(p_reg, Mock.nrf_gpio_port_out_read_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_out_read,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type const), cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_out_read_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_out_read_CallbackFunctionPointer(p_reg, Mock.nrf_gpio_port_out_read_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_out_read(CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type const* p_reg);
void CMockExpectParameters_nrf_gpio_port_out_read(CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type const* p_reg)
{
  cmock_call_instance->Expected_p_reg = p_reg;
}

void nrf_gpio_port_out_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_out_read_IgnoreBool = (char)1;
}

void nrf_gpio_port_out_read_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_out_read_IgnoreBool)
    Mock.nrf_gpio_port_out_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_read_CallInstance);
  Mock.nrf_gpio_port_out_read_IgnoreBool = (char)0;
}

void nrf_gpio_port_out_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type const* p_reg, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_out_read(cmock_call_instance, p_reg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce uint32_t[sizeof(cmock_to_return) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
}

void nrf_gpio_port_out_read_AddCallback(CMOCK_nrf_gpio_port_out_read_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_read_CallbackBool = (char)1;
  Mock.nrf_gpio_port_out_read_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_out_read_Stub(CMOCK_nrf_gpio_port_out_read_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_read_CallbackBool = (char)0;
  Mock.nrf_gpio_port_out_read_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_port_out_write(NRF_GPIO_Type* p_reg, uint32_t value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_write);
  cmock_call_instance = (CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_out_write_CallInstance);
  Mock.nrf_gpio_port_out_write_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_write_CallInstance);
  if (Mock.nrf_gpio_port_out_write_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_out_write_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_out_write_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_out_write_CallbackBool &&
      Mock.nrf_gpio_port_out_write_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_port_out_write_CallbackFunctionPointer(p_reg, value, Mock.nrf_gpio_port_out_write_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_out_write,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_out_write,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_value, value, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_out_write_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_out_write_CallbackFunctionPointer(p_reg, value, Mock.nrf_gpio_port_out_write_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_out_write(CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t value);
void CMockExpectParameters_nrf_gpio_port_out_write(CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t value)
{
  cmock_call_instance->Expected_p_reg = p_reg;
  cmock_call_instance->Expected_value = value;
}

void nrf_gpio_port_out_write_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_write_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_write_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_write_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_out_write_IgnoreBool = (char)1;
}

void nrf_gpio_port_out_write_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_out_write_IgnoreBool)
    Mock.nrf_gpio_port_out_write_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_write_CallInstance);
  Mock.nrf_gpio_port_out_write_IgnoreBool = (char)0;
}

void nrf_gpio_port_out_write_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type* p_reg, uint32_t value, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_write_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_write_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_write_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_write_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_out_write(cmock_call_instance, p_reg, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_port_out_write_AddCallback(CMOCK_nrf_gpio_port_out_write_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_write_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_write_CallbackBool = (char)1;
  Mock.nrf_gpio_port_out_write_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_out_write_Stub(CMOCK_nrf_gpio_port_out_write_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_write_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_write_CallbackBool = (char)0;
  Mock.nrf_gpio_port_out_write_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_port_out_set(NRF_GPIO_Type* p_reg, uint32_t set_mask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_set);
  cmock_call_instance = (CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_out_set_CallInstance);
  Mock.nrf_gpio_port_out_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_set_CallInstance);
  if (Mock.nrf_gpio_port_out_set_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_out_set_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_out_set_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_out_set_CallbackBool &&
      Mock.nrf_gpio_port_out_set_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_port_out_set_CallbackFunctionPointer(p_reg, set_mask, Mock.nrf_gpio_port_out_set_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_out_set,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_out_set,CMockString_set_mask);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_set_mask, set_mask, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_out_set_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_out_set_CallbackFunctionPointer(p_reg, set_mask, Mock.nrf_gpio_port_out_set_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_out_set(CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t set_mask);
void CMockExpectParameters_nrf_gpio_port_out_set(CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t set_mask)
{
  cmock_call_instance->Expected_p_reg = p_reg;
  cmock_call_instance->Expected_set_mask = set_mask;
}

void nrf_gpio_port_out_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_out_set_IgnoreBool = (char)1;
}

void nrf_gpio_port_out_set_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_out_set_IgnoreBool)
    Mock.nrf_gpio_port_out_set_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_set_CallInstance);
  Mock.nrf_gpio_port_out_set_IgnoreBool = (char)0;
}

void nrf_gpio_port_out_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type* p_reg, uint32_t set_mask, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_set_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_set_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_out_set(cmock_call_instance, p_reg, set_mask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_port_out_set_AddCallback(CMOCK_nrf_gpio_port_out_set_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_set_CallbackBool = (char)1;
  Mock.nrf_gpio_port_out_set_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_out_set_Stub(CMOCK_nrf_gpio_port_out_set_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_set_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_set_CallbackBool = (char)0;
  Mock.nrf_gpio_port_out_set_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_port_out_clear(NRF_GPIO_Type* p_reg, uint32_t clr_mask)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_port_out_clear);
  cmock_call_instance = (CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_port_out_clear_CallInstance);
  Mock.nrf_gpio_port_out_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_clear_CallInstance);
  if (Mock.nrf_gpio_port_out_clear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_port_out_clear_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_port_out_clear_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_port_out_clear_CallbackBool &&
      Mock.nrf_gpio_port_out_clear_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_port_out_clear_CallbackFunctionPointer(p_reg, clr_mask, Mock.nrf_gpio_port_out_clear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_out_clear,CMockString_p_reg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_p_reg), (void*)(p_reg), sizeof(NRF_GPIO_Type), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_port_out_clear,CMockString_clr_mask);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_clr_mask, clr_mask, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_port_out_clear_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_port_out_clear_CallbackFunctionPointer(p_reg, clr_mask, Mock.nrf_gpio_port_out_clear_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_port_out_clear(CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t clr_mask);
void CMockExpectParameters_nrf_gpio_port_out_clear(CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE* cmock_call_instance, NRF_GPIO_Type* p_reg, uint32_t clr_mask)
{
  cmock_call_instance->Expected_p_reg = p_reg;
  cmock_call_instance->Expected_clr_mask = clr_mask;
}

void nrf_gpio_port_out_clear_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_port_out_clear_IgnoreBool = (char)1;
}

void nrf_gpio_port_out_clear_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_port_out_clear_IgnoreBool)
    Mock.nrf_gpio_port_out_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_port_out_clear_CallInstance);
  Mock.nrf_gpio_port_out_clear_IgnoreBool = (char)0;
}

void nrf_gpio_port_out_clear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NRF_GPIO_Type* p_reg, uint32_t clr_mask, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_port_out_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_port_out_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_port_out_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_port_out_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_port_out_clear(cmock_call_instance, p_reg, clr_mask);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_port_out_clear_AddCallback(CMOCK_nrf_gpio_port_out_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_clear_CallbackBool = (char)1;
  Mock.nrf_gpio_port_out_clear_CallbackFunctionPointer = Callback;
}

void nrf_gpio_port_out_clear_Stub(CMOCK_nrf_gpio_port_out_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_port_out_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_port_out_clear_CallbackBool = (char)0;
  Mock.nrf_gpio_port_out_clear_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_ports_read(uint32_t start_port, uint32_t length, uint32_t* p_masks)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_ports_read_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_ports_read);
  cmock_call_instance = (CMOCK_nrf_gpio_ports_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_ports_read_CallInstance);
  Mock.nrf_gpio_ports_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_ports_read_CallInstance);
  if (Mock.nrf_gpio_ports_read_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_ports_read_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_ports_read_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_ports_read_CallbackBool &&
      Mock.nrf_gpio_ports_read_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_ports_read_CallbackFunctionPointer(start_port, length, p_masks, Mock.nrf_gpio_ports_read_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_ports_read,CMockString_start_port);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_start_port, start_port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_ports_read,CMockString_length);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_length, length, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_ports_read,CMockString_p_masks);
    if (cmock_call_instance->Expected_p_masks == NULL)
      { UNITY_TEST_ASSERT_NULL(p_masks, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY(cmock_call_instance->Expected_p_masks, p_masks, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.nrf_gpio_ports_read_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_ports_read_CallbackFunctionPointer(start_port, length, p_masks, Mock.nrf_gpio_ports_read_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_ports_read(CMOCK_nrf_gpio_ports_read_CALL_INSTANCE* cmock_call_instance, uint32_t start_port, uint32_t length, uint32_t* p_masks);
void CMockExpectParameters_nrf_gpio_ports_read(CMOCK_nrf_gpio_ports_read_CALL_INSTANCE* cmock_call_instance, uint32_t start_port, uint32_t length, uint32_t* p_masks)
{
  cmock_call_instance->Expected_start_port = start_port;
  cmock_call_instance->Expected_length = length;
  cmock_call_instance->Expected_p_masks = p_masks;
}

void nrf_gpio_ports_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_ports_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_ports_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_ports_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_ports_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_ports_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_ports_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_ports_read_IgnoreBool = (char)1;
}

void nrf_gpio_ports_read_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_ports_read_IgnoreBool)
    Mock.nrf_gpio_ports_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_ports_read_CallInstance);
  Mock.nrf_gpio_ports_read_IgnoreBool = (char)0;
}

void nrf_gpio_ports_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t start_port, uint32_t length, uint32_t* p_masks, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_ports_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_ports_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_ports_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_ports_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_ports_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_ports_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_ports_read(cmock_call_instance, start_port, length, p_masks);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_ports_read_AddCallback(CMOCK_nrf_gpio_ports_read_CALLBACK Callback)
{
  Mock.nrf_gpio_ports_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_ports_read_CallbackBool = (char)1;
  Mock.nrf_gpio_ports_read_CallbackFunctionPointer = Callback;
}

void nrf_gpio_ports_read_Stub(CMOCK_nrf_gpio_ports_read_CALLBACK Callback)
{
  Mock.nrf_gpio_ports_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_ports_read_CallbackBool = (char)0;
  Mock.nrf_gpio_ports_read_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_latches_read(uint32_t start_port, uint32_t length, uint32_t* p_masks)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_latches_read_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_latches_read);
  cmock_call_instance = (CMOCK_nrf_gpio_latches_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_latches_read_CallInstance);
  Mock.nrf_gpio_latches_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_latches_read_CallInstance);
  if (Mock.nrf_gpio_latches_read_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_latches_read_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_latches_read_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_latches_read_CallbackBool &&
      Mock.nrf_gpio_latches_read_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_latches_read_CallbackFunctionPointer(start_port, length, p_masks, Mock.nrf_gpio_latches_read_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_latches_read,CMockString_start_port);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_start_port, start_port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_latches_read,CMockString_length);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_length, length, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_latches_read,CMockString_p_masks);
    if (cmock_call_instance->Expected_p_masks == NULL)
      { UNITY_TEST_ASSERT_NULL(p_masks, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY(cmock_call_instance->Expected_p_masks, p_masks, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.nrf_gpio_latches_read_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_latches_read_CallbackFunctionPointer(start_port, length, p_masks, Mock.nrf_gpio_latches_read_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_latches_read(CMOCK_nrf_gpio_latches_read_CALL_INSTANCE* cmock_call_instance, uint32_t start_port, uint32_t length, uint32_t* p_masks);
void CMockExpectParameters_nrf_gpio_latches_read(CMOCK_nrf_gpio_latches_read_CALL_INSTANCE* cmock_call_instance, uint32_t start_port, uint32_t length, uint32_t* p_masks)
{
  cmock_call_instance->Expected_start_port = start_port;
  cmock_call_instance->Expected_length = length;
  cmock_call_instance->Expected_p_masks = p_masks;
}

void nrf_gpio_latches_read_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_latches_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_latches_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_latches_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_latches_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_latches_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_latches_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_latches_read_IgnoreBool = (char)1;
}

void nrf_gpio_latches_read_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_latches_read_IgnoreBool)
    Mock.nrf_gpio_latches_read_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_latches_read_CallInstance);
  Mock.nrf_gpio_latches_read_IgnoreBool = (char)0;
}

void nrf_gpio_latches_read_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t start_port, uint32_t length, uint32_t* p_masks, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_latches_read_CALL_INSTANCE));
  CMOCK_nrf_gpio_latches_read_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_latches_read_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_latches_read_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_latches_read_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_latches_read_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_latches_read(cmock_call_instance, start_port, length, p_masks);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_latches_read_AddCallback(CMOCK_nrf_gpio_latches_read_CALLBACK Callback)
{
  Mock.nrf_gpio_latches_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_latches_read_CallbackBool = (char)1;
  Mock.nrf_gpio_latches_read_CallbackFunctionPointer = Callback;
}

void nrf_gpio_latches_read_Stub(CMOCK_nrf_gpio_latches_read_CALLBACK Callback)
{
  Mock.nrf_gpio_latches_read_IgnoreBool = (char)0;
  Mock.nrf_gpio_latches_read_CallbackBool = (char)0;
  Mock.nrf_gpio_latches_read_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_latches_read_and_clear(uint32_t start_port, uint32_t length, uint32_t* p_masks)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_latches_read_and_clear);
  cmock_call_instance = (CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_latches_read_and_clear_CallInstance);
  Mock.nrf_gpio_latches_read_and_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_latches_read_and_clear_CallInstance);
  if (Mock.nrf_gpio_latches_read_and_clear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_latches_read_and_clear_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_latches_read_and_clear_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_latches_read_and_clear_CallbackBool &&
      Mock.nrf_gpio_latches_read_and_clear_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_latches_read_and_clear_CallbackFunctionPointer(start_port, length, p_masks, Mock.nrf_gpio_latches_read_and_clear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_latches_read_and_clear,CMockString_start_port);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_start_port, start_port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_latches_read_and_clear,CMockString_length);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_length, length, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_latches_read_and_clear,CMockString_p_masks);
    if (cmock_call_instance->Expected_p_masks == NULL)
      { UNITY_TEST_ASSERT_NULL(p_masks, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_UINT32_ARRAY(cmock_call_instance->Expected_p_masks, p_masks, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.nrf_gpio_latches_read_and_clear_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_latches_read_and_clear_CallbackFunctionPointer(start_port, length, p_masks, Mock.nrf_gpio_latches_read_and_clear_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_latches_read_and_clear(CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE* cmock_call_instance, uint32_t start_port, uint32_t length, uint32_t* p_masks);
void CMockExpectParameters_nrf_gpio_latches_read_and_clear(CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE* cmock_call_instance, uint32_t start_port, uint32_t length, uint32_t* p_masks)
{
  cmock_call_instance->Expected_start_port = start_port;
  cmock_call_instance->Expected_length = length;
  cmock_call_instance->Expected_p_masks = p_masks;
}

void nrf_gpio_latches_read_and_clear_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_latches_read_and_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_latches_read_and_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_latches_read_and_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_latches_read_and_clear_IgnoreBool = (char)1;
}

void nrf_gpio_latches_read_and_clear_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_latches_read_and_clear_IgnoreBool)
    Mock.nrf_gpio_latches_read_and_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_latches_read_and_clear_CallInstance);
  Mock.nrf_gpio_latches_read_and_clear_IgnoreBool = (char)0;
}

void nrf_gpio_latches_read_and_clear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t start_port, uint32_t length, uint32_t* p_masks, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_latches_read_and_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_latches_read_and_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_latches_read_and_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_latches_read_and_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_latches_read_and_clear(cmock_call_instance, start_port, length, p_masks);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_latches_read_and_clear_AddCallback(CMOCK_nrf_gpio_latches_read_and_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_latches_read_and_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_latches_read_and_clear_CallbackBool = (char)1;
  Mock.nrf_gpio_latches_read_and_clear_CallbackFunctionPointer = Callback;
}

void nrf_gpio_latches_read_and_clear_Stub(CMOCK_nrf_gpio_latches_read_and_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_latches_read_and_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_latches_read_and_clear_CallbackBool = (char)0;
  Mock.nrf_gpio_latches_read_and_clear_CallbackFunctionPointer = Callback;
}

inluce uint32_t nrf_gpio_pin_latch_get(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_latch_get);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_latch_get_CallInstance);
  Mock.nrf_gpio_pin_latch_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_latch_get_CallInstance);
  if (Mock.nrf_gpio_pin_latch_get_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_latch_get_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_latch_get_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce uint32_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_latch_get_CallbackBool &&
      Mock.nrf_gpio_pin_latch_get_CallbackFunctionPointer != NULL)
  {
    inluce uint32_t cmock_cb_ret = Mock.nrf_gpio_pin_latch_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_latch_get_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_latch_get,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_latch_get_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_latch_get_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_latch_get_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_latch_get(CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_latch_get(CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_latch_get_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_latch_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_latch_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_latch_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_latch_get_IgnoreBool = (char)1;
}

void nrf_gpio_pin_latch_get_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_latch_get_IgnoreBool)
    Mock.nrf_gpio_pin_latch_get_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_latch_get_CallInstance);
  Mock.nrf_gpio_pin_latch_get_IgnoreBool = (char)0;
}

void nrf_gpio_pin_latch_get_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_latch_get_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_latch_get_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_latch_get_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_latch_get_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_latch_get(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce uint32_t[sizeof(cmock_to_return) == sizeof(inluce uint32_t) ? 1 : -1])); /* add inluce uint32_t to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_latch_get_AddCallback(CMOCK_nrf_gpio_pin_latch_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_latch_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_latch_get_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_latch_get_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_latch_get_Stub(CMOCK_nrf_gpio_pin_latch_get_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_latch_get_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_latch_get_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_latch_get_CallbackFunctionPointer = Callback;
}

inluce void nrf_gpio_pin_latch_clear(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_latch_clear);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_latch_clear_CallInstance);
  Mock.nrf_gpio_pin_latch_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_latch_clear_CallInstance);
  if (Mock.nrf_gpio_pin_latch_clear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_latch_clear_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_latch_clear_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce void[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_latch_clear_CallbackBool &&
      Mock.nrf_gpio_pin_latch_clear_CallbackFunctionPointer != NULL)
  {
    inluce void cmock_cb_ret = Mock.nrf_gpio_pin_latch_clear_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_latch_clear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_latch_clear,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_latch_clear_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_latch_clear_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_latch_clear_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_latch_clear(CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_latch_clear(CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_latch_clear_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_latch_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_latch_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_latch_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_latch_clear_IgnoreBool = (char)1;
}

void nrf_gpio_pin_latch_clear_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_latch_clear_IgnoreBool)
    Mock.nrf_gpio_pin_latch_clear_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_latch_clear_CallInstance);
  Mock.nrf_gpio_pin_latch_clear_IgnoreBool = (char)0;
}

void nrf_gpio_pin_latch_clear_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce void cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_latch_clear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_latch_clear_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_latch_clear_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_latch_clear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_latch_clear(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce void[sizeof(cmock_to_return) == sizeof(inluce void) ? 1 : -1])); /* add inluce void to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_latch_clear_AddCallback(CMOCK_nrf_gpio_pin_latch_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_latch_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_latch_clear_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_latch_clear_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_latch_clear_Stub(CMOCK_nrf_gpio_pin_latch_clear_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_latch_clear_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_latch_clear_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_latch_clear_CallbackFunctionPointer = Callback;
}

inluce bool nrf_gpio_pin_present_check(uint32_t pin_number)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nrf_gpio_pin_present_check);
  cmock_call_instance = (CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nrf_gpio_pin_present_check_CallInstance);
  Mock.nrf_gpio_pin_present_check_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_present_check_CallInstance);
  if (Mock.nrf_gpio_pin_present_check_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nrf_gpio_pin_present_check_FinalReturn;
    memcpy((void*)(&Mock.nrf_gpio_pin_present_check_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(inluce bool[sizeof(cmock_call_instance->ReturnVal) == sizeof(inluce bool) ? 1 : -1])); /* add inluce bool to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.nrf_gpio_pin_present_check_CallbackBool &&
      Mock.nrf_gpio_pin_present_check_CallbackFunctionPointer != NULL)
  {
    inluce bool cmock_cb_ret = Mock.nrf_gpio_pin_present_check_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_present_check_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_nrf_gpio_pin_present_check,CMockString_pin_number);
    UNITY_TEST_ASSERT_EQUAL_UINT32(cmock_call_instance->Expected_pin_number, pin_number, cmock_line, CMockStringMismatch);
  }
  if (Mock.nrf_gpio_pin_present_check_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.nrf_gpio_pin_present_check_CallbackFunctionPointer(pin_number, Mock.nrf_gpio_pin_present_check_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nrf_gpio_pin_present_check(CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number);
void CMockExpectParameters_nrf_gpio_pin_present_check(CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE* cmock_call_instance, uint32_t pin_number)
{
  cmock_call_instance->Expected_pin_number = pin_number;
}

void nrf_gpio_pin_present_check_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, inluce bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_present_check_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_present_check_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_present_check_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nrf_gpio_pin_present_check_IgnoreBool = (char)1;
}

void nrf_gpio_pin_present_check_CMockStopIgnore(void)
{
  if(Mock.nrf_gpio_pin_present_check_IgnoreBool)
    Mock.nrf_gpio_pin_present_check_CallInstance = CMock_Guts_MemNext(Mock.nrf_gpio_pin_present_check_CallInstance);
  Mock.nrf_gpio_pin_present_check_IgnoreBool = (char)0;
}

void nrf_gpio_pin_present_check_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t pin_number, inluce bool cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE));
  CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE* cmock_call_instance = (CMOCK_nrf_gpio_pin_present_check_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nrf_gpio_pin_present_check_CallInstance = CMock_Guts_MemChain(Mock.nrf_gpio_pin_present_check_CallInstance, cmock_guts_index);
  Mock.nrf_gpio_pin_present_check_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_nrf_gpio_pin_present_check(cmock_call_instance, pin_number);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(inluce bool[sizeof(cmock_to_return) == sizeof(inluce bool) ? 1 : -1])); /* add inluce bool to :treat_as_array if this causes an error */
}

void nrf_gpio_pin_present_check_AddCallback(CMOCK_nrf_gpio_pin_present_check_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_present_check_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_present_check_CallbackBool = (char)1;
  Mock.nrf_gpio_pin_present_check_CallbackFunctionPointer = Callback;
}

void nrf_gpio_pin_present_check_Stub(CMOCK_nrf_gpio_pin_present_check_CALLBACK Callback)
{
  Mock.nrf_gpio_pin_present_check_IgnoreBool = (char)0;
  Mock.nrf_gpio_pin_present_check_CallbackBool = (char)0;
  Mock.nrf_gpio_pin_present_check_CallbackFunctionPointer = Callback;
}

